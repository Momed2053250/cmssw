// CMSSW includes
#include "DataFormats/FEDRawData/interface/StripPixelHostCollection.h"
#include "DataFormats/Phase2TrackerCluster/interface/ClusterPropHostCollection.h"
#include "DataFormats/FEDRawData/interface/alpaka/StripPixelDeviceCollection.h"
#include "DataFormats/Phase2TrackerCluster/interface/ClusterPropDeviceCollection.h"

#include "DataFormats/Portable/interface/alpaka/PortableCollection.h"
#include "DataFormats/Phase2TrackerCluster/interface/alpaka/ClusterPropSoACollection.h"
#include "FWCore/Framework/interface/MakerMacros.h"
#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
#include "FWCore/ParameterSet/interface/ParameterSet.h"
#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
#include "FWCore/MessageLogger/interface/MessageLogger.h"
#include "FWCore/Utilities/interface/InputTag.h"
#include "FWCore/Utilities/interface/StreamID.h"

#include "HeterogeneousCore/AlpakaCore/interface/alpaka/stream/EDProducer.h"
#include "HeterogeneousCore/AlpakaCore/interface/alpaka/EDPutToken.h"
#include "HeterogeneousCore/AlpakaCore/interface/alpaka/ESGetToken.h"
#include "HeterogeneousCore/AlpakaCore/interface/alpaka/Event.h"

#include "HeterogeneousCore/AlpakaInterface/interface/config.h"
#include "HeterogeneousCore/AlpakaInterface/interface/CopyToDevice.h"
#include "HeterogeneousCore/AlpakaInterface/interface/CopyToHost.h"
#include "HeterogeneousCore/AlpakaInterface/interface/workdivision.h"

#include "FWCore/Framework/interface/Event.h"
#include "FWCore/Framework/interface/Frameworkfwd.h"

#include "CondFormats/SiPhase2TrackerObjects/interface/TrackerDetToDTCELinkCablingMap.h"
#include "CondFormats/SiPhase2TrackerObjects/interface/DTCELinkId.h"
#include "CondFormats/DataRecord/interface/TrackerDetToDTCELinkCablingMapRcd.h"

#include "DataFormats/Common/interface/DetSetVectorNew.h"
#include "DataFormats/Common/interface/Handle.h"
#include "DataFormats/FEDRawData/interface/FEDRawDataCollection.h"
#include "DataFormats/Phase2TrackerCluster/interface/Phase2TrackerCluster1D.h"

#include "DataFormats/TrackerCommon/interface/TrackerTopology.h"
#include "Geometry/Records/interface/TrackerDigiGeometryRecord.h"
#include "Geometry/TrackerGeometryBuilder/interface/TrackerGeometry.h"
#include "Geometry/CommonTopologies/interface/PixelGeomDetUnit.h"
#include "Geometry/CommonTopologies/interface/PixelTopology.h"
#include <unordered_map>

#include "EventFilter/Phase2TrackerRawToDigi/interface/TrackerHeader.h"
#include "EventFilter/Phase2TrackerRawToDigi/interface/ChannelsOffset.h"
#include "EventFilter/Phase2TrackerRawToDigi/interface/Phase2TrackerSpecifications.h"
#include "EventFilter/Phase2TrackerRawToDigi/interface/Phase2DAQFormatSpecification.h"
//#include "EventFilter/Phase2TrackerRawToDigi/plugins/alpaka/RawToCluster.dev.cc"
#include "EventFilter/Phase2TrackerRawToDigi/plugins/alpaka/RawToClusterAlgo.h"
#include <iomanip> // for std::setw
#include <future>
#include "FWCore/Framework/interface/ESWatcher.h"

//From the CPU based code 
using namespace Phase2TrackerSpecifications;
using namespace Phase2DAQFormatSpecification;
using namespace Phase2RawToCluster;
// just a peaceful timer 
template<class T> double duration(T t0,T t1)
{
  auto elapsed_secs = t1-t0;
  typedef std::chrono::duration<float> float_seconds;
  auto secs = std::chrono::duration_cast<float_seconds>(elapsed_secs);
  return secs.count();
}

inline std::chrono::time_point<std::chrono::steady_clock> now()
{
  return std::chrono::steady_clock::now();
}

namespace ALPAKA_ACCELERATOR_NAMESPACE {

  using namespace cms::alpakatools;
// enum // enumaration declariation 

 // enum ModuleType (undef, 2S ,PS i);


  class Phase2RawToClusterProducer : public stream::EDProducer<> {
  public:
    explicit Phase2RawToClusterProducer(const edm::ParameterSet&);
    static void fillDescriptions(edm::ConfigurationDescriptions&);
// enum 
enum WhichModule:int {undef, TwoS ,PS };
  private:
    void produce(device::Event&, device::EventSetup const&) override;
    void beginRun(edm::Run const&, edm::EventSetup const&) override;
   //  edm::ESWatcher<HGCalCondSerializableModuleInfoRcd> calibWatcher_;
  //  edm::ESWatcher<HGCalCondSerializableConfigRcd> configWatcher_;
  // Token
    const edm::EDGetTokenT<FEDRawDataCollection> fedRawDataToken_;
    const edm::ESGetToken<TrackerDetToDTCELinkCablingMap, TrackerDetToDTCELinkCablingMapRcd> cablingMapToken_;
    const edm::ESGetToken<TrackerGeometry, TrackerDigiGeometryRecord> trackerGeometryToken_;
    const edm::ESGetToken<TrackerTopology, TrackerTopologyRcd> trackerTopologyToken_;
   // edm::EDGetTokenT<Phase2TrackerCluster1DCollectionNew> OutputClusterCollectionToken_;
    // our new output token
    //cms::alpaka
	   device::EDPutToken<Phase2RawToCluster::ClusterPropSoACollection> outputToken_;

       // cached ES pointers
    const TrackerDetToDTCELinkCablingMap* cablingMap_ = nullptr;
    const TrackerGeometry* trackerGeometry_ = nullptr;
    const TrackerTopology* trackerTopology_ = nullptr;
    std::map<int, std::pair<int,int>> stackMap_;
    // make the host buffers 
    // DTC*slink *channel -> DetIdx 
    cms::alpakatools::host_buffer<int[]> detIdxModuleTypeMap_;
    cms::alpakatools::device_buffer<Device, int[]> detIdxModuleTypeDevice_;
    Queue  myqueue;
  };

    Phase2RawToClusterProducer::Phase2RawToClusterProducer(const edm::ParameterSet& iConfig)
    : stream::EDProducer<>(iConfig),
     fedRawDataToken_(consumes<FEDRawDataCollection>(iConfig.getParameter<edm::InputTag>("fedRawDataCollection"))),
      cablingMapToken_(esConsumes<TrackerDetToDTCELinkCablingMap, TrackerDetToDTCELinkCablingMapRcd, edm::Transition::BeginRun>()),
      trackerGeometryToken_(esConsumes<TrackerGeometry, TrackerDigiGeometryRecord, edm::Transition::BeginRun>()),
      trackerTopologyToken_(esConsumes<TrackerTopology, TrackerTopologyRcd, edm::Transition::BeginRun>()),
      
	// outputToken_(produces())
	//outputToken_{produces<Phase2RawToCluster::ClusterPropHostCollection>()}
	outputToken_{ produces()},
	//
//	detIdxModuleTypeMap_{cms::alpakatools::make_host_buffer<int[], Platform>((MAX_DTC_ID - MIN_DTC_ID) * SLINKS_PER_DTC * CICs_PER_SLINK )} //,
//	detIdxModuleTypeDevice_{cms::alpakatools::make_device_buffer<int[], Device>((MAX_DTC_ID - MIN_DTC_ID) * SLINKS_PER_DTC * CICs_PER_SLINK )}
    
       //		.template deviceProduces<Phase2RawToCluster::ClusterPropDeviceCollection, Phase2RawToCluster::ClusterPropHostCollection>() }
// outputToken_{ produces<Phase2RawToCluster::ClusterPropHostCollection>() }
	{
		detIdxModuleTypeMap_ = cms::alpakatools::make_host_buffer<int[]>(myqueue, (MAX_DTC_ID - MIN_DTC_ID) * SLINKS_PER_DTC * CICs_PER_SLINK );
		detIdxModuleTypeDevice_ = cms::alpakatools::make_device_buffer<int[]>(myqueue ,(MAX_DTC_ID - MIN_DTC_ID) * SLINKS_PER_DTC * CICs_PER_SLINK );

	}

//Phase2RawToClusterProducer::~Phase2RawToClusterProducer() 
//{
//}

  void Phase2RawToClusterProducer::beginRun(
      edm::Run const&, edm::EventSetup const& iSetup) {
    cablingMap_     = &iSetup.getData(cablingMapToken_);
    trackerGeometry_ = &iSetup.getData(trackerGeometryToken_);
    trackerTopology_ = &iSetup.getData(trackerTopologyToken_);

    stackMap_.clear();
    for (auto const& detUnit : trackerGeometry_->detUnits()) {
      uint32_t rawId = detUnit->geographicalId().rawId();
      DetId detId(rawId);
      if (detId.det() != DetId::Detector::Tracker) continue;
      int stackIdx = trackerTopology_->stack(detId);
      if (trackerTopology_->isLower(detId))
        stackMap_[stackIdx].first = rawId;
      if (trackerTopology_->isUpper(detId))
        stackMap_[stackIdx].second = rawId;
    }
 
    // Read one entire DTC (#dtcID), as per the producer logic
//     unsigned int dtcID = 180; // dtc processing 2S modules
//     unsigned int dtcID = 209; // dtc processing PS modules
    for (int dtcID = MIN_DTC_ID; dtcID < MAX_DTC_ID + 1; dtcID++){

      // read the 4 slinks
      for (unsigned int iSlink = 0; iSlink < SLINKS_PER_DTC; iSlink++)
      {
        // as defined in the DAQProducer code
        unsigned totID = iSlink + SLINKS_PER_DTC * (dtcID - 1) + CMSSW_TRACKER_ID ;
               
       
	  // now read the payload (channel header + clusters)
          // all channel headers should be there, even if 0 clusters are found
          // the loop is not on the actual channel number, as in the ClusterToRaw conversion each channel is split by CIC0_CIC1
          // NOTE: we need to save into the Phase2TrackerCluster1D collection two "channels" at the time
          // in order to get all the clusters from the same lpGBT and fill them once at the end
                for (unsigned int iChannel = 0; iChannel < CICs_PER_SLINK; iChannel++)
          {
            // retrieve the module type:
            // first we need to construct the DTCElinkId object ## dtc_id, gbtlink_id, elink_id
            // to get the gbt_id we should reverse what is done in the packer function,
            // where clusters from channel X are split into 2*i and 2*i+1 based on being from CIC0 or CIC1
				
            unsigned int gbt_id = iSlink * MODULES_PER_SLINK + std::div(iChannel, 2).quot;
            DTCELinkId thisDTCElinkId(dtcID, gbt_id, 0);

            int thisDetId = -1;
            bool is2SModule = false;
       
       	    auto DetIdx = iChannel + (CICs_PER_SLINK * iSlink) + (CICs_PER_SLINK * SLINKS_PER_DTC * (dtcID - MIN_DTC_ID));
   
	    // then pass it to the map to get the detid
            if (cablingMap_->knowsDTCELinkId(thisDTCElinkId))
            {
              auto possibleDetIds = cablingMap_->dtcELinkIdToDetId(thisDTCElinkId); // this returns a pair, detid will be an uint32_t (not a DetId)
              thisDetId = possibleDetIds->second;
              LogTrace("RawToClusterProducer") << "slink: " << iSlink << "\tiDTC: " << unsigned(dtcID) << "\tiGBT: " << unsigned(gbt_id)
                                               << "\tielink: " << unsigned(0) << "\t -> detId:" << thisDetId;
              // check is 2S or PS
              is2SModule = trackerGeometry_->getDetectorType( stackMap_[thisDetId].first) == TrackerGeometry::ModuleType::Ph2SS;
		detIdxModuleTypeMap_[DetIdx] = is2SModule ? WhichModule::TwoS : WhichModule::PS;		
	    }
            else {
              LogTrace("RawToClusterProducer") << "slink: " << iSlink << "\tiDTC: " << unsigned(dtcID) << "\tiGBT: " << unsigned(gbt_id)
                                               << " -> not connected? " ;
	      detIdxModuleTypeMap_[DetIdx] = WhichModule::undef;
              continue;
	    }
	  } // channel 

      } // slink 
    } // det id 
  }

  void Phase2RawToClusterProducer::produce(
      device::Event& iEvent, device::EventSetup const&) {
    auto queue = iEvent.queue();
/*
    // Read digis
   // auto const& deviceCalibParamProvider = iSetup.getData(calibToken_);
  //  auto const& deviceConfigParamProvider = iSetup.getData(configToken_);
  //  auto const& hostDigisIn = iEvent.get(digisToken_);


    
    // Create and fill host digi collection 
    // Construct new containers to hold data in host 
   // auto hostDigis = HGCalDigiHostCollection(newSize, queue);
   //	int size = some token.view().metadata().size(); ///will decide later 
	//auto hostStripPixel = StripPixelHostCollection(size, queue);
    for(int i=0; i<size;i++){
  //    hostStripPixel.view()[i].stripClusterWords() = some token.view()[i].stripClusterWords();
  //    hostStripPixel.view()[i].pixelClusterWords() = some token.view()[i].pixelClusterWords();
  
    }
*/
/*
    	// 1) Load raw FED words into host vector
  	auto const& rawColl = iEvent.get(fedRawDataToken_);
  	size_t totalWords = 0;
  	for (auto const& fedIt : rawColl) {
    	totalWords += fedIt.second.size() / sizeof(uint32_t);
  	}
  	std::vector<uint32_t> rawWords;
  	rawWords.reserve(totalWords);
  	for (auto const& fedIt : rawColl) {
    	auto ptr32 = reinterpret_cast<const uint32_t*>(fedIt.second.data());
    	auto nWords = fedIt.second.size() / sizeof(uint32_t);
    	rawWords.insert(rawWords.end(), ptr32, ptr32 + nWords);
  	}cms::alpakatools::make_host_buffer<Product>()}, product_{buffer_->data()
*/
	// 1) Build the flat raw‐word array from exactly those FEDs the cabling map knows:

	auto const& rawColl = iEvent.get(fedRawDataToken_);
	auto hostview = cms::alpakatools::make_host_view<const FEDRawData>(rawColl.data(), static_cast<long unsigned int>(rawColl.size()));
	auto devbuffer = cms::alpakatools::make_device_buffer<FEDRawData[]>(queue, static_cast<long unsigned int>(rawColl.size()));
	alpaka::memcpy(
            queue,
            devbuffer,        // device destination pointer
            hostview , // host source pointer
            static_cast< unsigned int>( rawColl.size() * sizeof(FEDRawData))  // total bytes to copy
          );
          // wait for the copy to finish before launching your kernel
        alpaka::wait(queue);

	launchUnpacker(queue,rawColl)

/*
	// (a) Ask the map for every DTCELinkId it knows
	auto dtcLinkIds = cablingMap_->getKnownDTCELinkIds();

	// (b) Turn each DTCELinkId into a unique FED ID
	std::vector<int> fedIds;
	fedIds.reserve(dtcLinkIds.size());
	for (auto const& linkId : dtcLinkIds) {
	  // extract the DTC number (1…MAX_DTC_ID) and the S-link index (0…SLINKS_PER_DTC-1)
	  unsigned dtcId     = linkId.dtc_id();
	  unsigned slinkIdx  = linkId.gbtlink_id();

	  int fedId = slinkIdx
	            + SLINKS_PER_DTC * (dtcId - 1)
	            + CMSSW_TRACKER_ID;
	  fedIds.push_back(fedId);
	}

	// sort+unique so we don’t double-count any
	std::sort(fedIds.begin(), fedIds.end());
	fedIds.erase(std::unique(fedIds.begin(), fedIds.end()), fedIds.end());

	// (c) First pass: count total 32-bit words
	size_t totalWords = 0;
	for (int fedId : fedIds) {
	  auto const& fed = rawColl.FEDData(fedId);
	  totalWords += fed.size() / sizeof(uint32_t);
	}

	// (d) Reserve and fill the flat word array
	std::vector<uint32_t> rawWords;
	rawWords.reserve(totalWords);

	for (int fedId : fedIds) {
	  auto const& fed = rawColl.FEDData(fedId);
	  auto ptr32  = reinterpret_cast<const uint32_t*>(fed.data());
	  auto nWords = fed.size() / sizeof(uint32_t);
	  rawWords.insert(rawWords.end(), ptr32, ptr32 + nWords);
	}


  	// 2) Fill host input SOA
  	auto hostStripPixel = StripPixelHostCollection(totalWords, queue);
  	for (size_t i = 0; i < totalWords; ++i) {
    	hostStripPixel.view()[i].stripClustersWords() = rawWords[i];
  	}

	  // 3) Allocate device input buffer and memcpy the host SOA into it
	Phase2RawToCluster::StripPixelDeviceCollection devStripPixel(totalWords, queue);
	//aloocating a buffer 
//	const uint32_t wordCounter = 0;
//	      auto buffer = cms::alpakatools::make_device_buffer<uint32_t[]>(queue, wordCounter);
	  alpaka::memcpy(
	    queue,
	    devStripPixel.buffer(),        // device destination pointer
	    hostStripPixel.buffer() //, // host source pointer
	  //  totalWords * sizeof(Phase2RawToCluster::StripPixelSoA::SoALayout)  // total bytes to copy
	  );
	  // once you know devStripPixel is filled, allocate the device output SOA
	  Phase2RawToCluster::ClusterPropDeviceCollection devClusterProp(totalWords, queue);
	  // wait for the copy to finish before launching your kernel
//cms::alpakatools::CopyToDevice(queue, devStripPixel, hostStripPixel);
	alpaka::wait(queue);

	// 4) Launch 2S unpacker
   	launchS2UnpackerKernel(queue, devStripPixel, devClusterProp, totalWords);
	alpaka::wait(queue);


	  // 5) Allocate a host-side SOA for the output and memcpy the result back
//	  ClusterPropHostCollection 
	 Phase2RawToCluster::ClusterPropSoACollection  hostClusterProp(totalWords, queue);
	  alpaka::memcpy(
	    queue,
	    hostClusterProp.buffer(),      // host destination pointer
	    devClusterProp.const_buffer() //, // device source pointer
	 //   totalWords * sizeof(Phase2RawToCluster::ClusterPropSoA::SoALayout)
	  );
	  // wait for the device→host copy to complete
	  alpaka::wait(queue);
	  // finally, put it into the event
	  iEvent.emplace(outputToken_, std::move(hostClusterProp));
	// call the unoacker kernal 
	 
	
*/
  } //produce 


	void Phase2RawToClusterProducer::fillDescriptions(edm::ConfigurationDescriptions& descriptions) {
  	edm::ParameterSetDescription desc;
  	desc.add<edm::InputTag>("fedRawDataCollection");
  	descriptions.addWithDefaultLabel(desc);
  }



  }  // namespace ALPAKA_ACCELERATOR_NAMESPACE

// define this as a plug-in
#include "HeterogeneousCore/AlpakaCore/interface/alpaka/MakerMacros.h"
DEFINE_FWK_ALPAKA_MODULE(Phase2RawToClusterProducer);
